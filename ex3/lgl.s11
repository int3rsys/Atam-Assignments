. = torg + 1000
main:   mov #main, sp

        jsr r5, isLegal
        .word OrigImg
        .word nRows
        .word nCols
        .word 0

        jmp finish

isLegal: ; 0(r5)=Img , 2(r5)=nRows , 4(r5)=nCols , 6(r5)=OUTPUT

              mov r1, -(sp)
              mov r2, -(sp)
              mov r3, -(sp)

              mov (r5), r1       ; (r5)=Img

lglByte:      cmpb (r1), #17
              bhi lglFalse          ; if [0 <= (r1) <= 17]

              movb @2(r5), r2       ; @2(r5)=nRows
              movb @4(r5), r3       ; @4(r5)=nCols
              mul r2, r3         ; r3=nCols*nRows

              add (r5), r3      ; (r5)=Img1
              dec r3
              cmp r3, r1
              ble lglTrue       ; if r1 reached the end of Img

              inc r1
              br lglByte

lglFalse:     mov #0, 6(r5)
              br lglFinish

lglTrue:      mov #1, 6(r5)
              br lglFinish

lglFinish:    mov (sp)+, r3
              mov (sp)+, r2
              mov (sp)+, r1
              add #10, r5
              rts r5

finish: halt
.= torg + 11000
nCols: 		.byte 10
nRows: 	.byte 4
OrigImg: 	.byte	 1,  2,  1,  2, 0,   1,   2,    3
				.byte	 3,  4,  3,  4, 4,   5,   6,    7
				.byte	 5,  6,  5,  6, 10, 11, 12, 13
				.byte	 7,  0,  7,  0, 14, 15, 16, 17
EncImg: 	.byte	 3,  4,  3,  4,  2,  3,   4,    5
				.byte	 7,  4,  7,  4,  10,   7,   6,    11
				.byte	 7,  10,  7,  10, 14, 15, 12, 13
				.byte	 3,  10,  3,  10, 16, 1, 0, 17
Hash:		.byte 	2,3,4,5,6,7,10,11,12,13,14,15,16,17,0,1
.even
Key:
node1:		.word -1, node2
node2:		.word -1, node3
node3:		.word -1, 0
ExpKey:
_node1:		.word  0, _node2
_node2:		.word  1, _node3
_node3:		.word  2, 0
