Technion Computer Science Department -- PDP/11 X-Assembler Version (5.5) AA.


	S O U R C E    F I L E    :    D:\workspace\Atom\234118\ex3\system.s11
	======================================================================

000000                             1     . = torg + 1000
001000   012706 001000             2     main:	mov	#main,	sp
001004   005001                    3               clr r1
001006   005002                    4               clr r2
001010   116701 007764             5               movb nCols, r1          ;checks whether nCols or nRows equal to zero
001014   116702 007761             6               movb nRows, r2
001020   005701                    7               tst r1
001022   001433                    8               beq jumpFinish
001024   005702                    9               tst r2
001026   001431                   10               beq jumpFinish
                                  11     
001030   004567 002012            12               jsr r5, isLegal
001034   011002                   13               .word OrigImg
001036   011001                   14               .word nRows
001040   011000                   15               .word nCols
001042   000000                   16               .word 0
                                  17     
001044   010701                   18               mov pc, r1
001046   162701 000004            19               sub #4, r1   ; cmp output address
                                  20     
001052   005711                   21               tst (r1)
001054   001416                   22               beq jumpFinish
                                  23     
001056   012746 011002            24               mov #OrigImg, -(sp)
001062   012746 011042            25               mov #EncImg, -(sp)
001066   012746 011001            26               mov #nRows, -(sp)
001072   012746 011000            27               mov #nCols, -(sp)
001076   012746 011102            28               mov #Hash, -(sp)
001102   004767 000010            29               jsr pc, system
                                  30     
001106   062706 000012            31               add #12, sp
                                  32     
001112   000167 002216            33     jumpFinish: jmp finish
                                  34     
001116                            35     system: ; 2(sp)=Hash , 4(sp)=nCols , 6(sp)=nRows , 10(sp)=EncImg , 12(sp)=OrigImg , Key=OUTPUT
                                  36     
001116   010146                   37               mov r1, -(sp)
                                  38     
001120   005746                   39               tst -(sp)
001122   016646 000016            40               mov 16(sp), -(sp)     ; 16(sp)=OrigImg
001126   016646 000016            41               mov 16(sp), -(sp)     ; 16(sp)=EncImg
001132   016646 000016            42               mov 16(sp), -(sp)     ; 16(sp)=nRows
001136   016646 000016            43               mov 16(sp), -(sp)     ; 16(sp)=nCols
001142   004767 002000            44               jsr pc, cmpImg
001146   062706 000010            45               add #10, sp
                                  46     
001152   005726                   47               tst (sp)+
001154   001460                   48               beq sysFinish         ; checks if EncImg == OrigImg
                                  49     
001156   012701 011122            50     sysFind:  mov #Key, r1
001162   004767 002072            51               jsr pc, nextKey
                                  52     
001166   016646 000014            53               mov 14(sp), -(sp)     ; 14(sp)=OrigImg
001172   016646 000012            54               mov 12(sp), -(sp)     ; 12(sp)=nRows
001176   016646 000012            55               mov 12(sp), -(sp)     ; 12(sp)=nCols
001202   016646 000012            56               mov 12(sp), -(sp)     ; 12(sp)=Hash
001206   012746 011122            57               mov #Key, -(sp)
001212   004767 000104            58               jsr pc, encode        ; encoding for comparison
001216   062706 000012            59               add #12, sp
                                  60     
001222   005746                   61               tst -(sp)
001224   016646 000016            62               mov 16(sp), -(sp)     ; 16(sp)=OrigImg
001230   016646 000016            63               mov 16(sp), -(sp)     ; 16(sp)=EncImg
001234   016646 000016            64               mov 16(sp), -(sp)     ; 16(sp)=nRows
001240   016646 000016            65               mov 16(sp), -(sp)     ; 16(sp)=nCols
001244   004767 001676            66               jsr pc, cmpImg
001250   062706 000010            67               add #10, sp
                                  68     
001254   005726                   69               tst (sp)+
001256   001417                   70               beq sysFinish         ; checks if EncImg == OrigImg
                                  71     
001260   016646 000014            72               mov 14(sp), -(sp)     ; 14(sp)=OrigImg
001264   016646 000012            73               mov 12(sp), -(sp)     ; 12(sp)=nRows
001270   016646 000012            74               mov 12(sp), -(sp)     ; 12(sp)=nCols
001274   016646 000012            75               mov 12(sp), -(sp)     ; 12(sp)=Hash
001300   012746 011122            76               mov #Key, -(sp)
001304   004767 000656            77               jsr pc, decode        ; decoding OrigImg after encryption
001310   062706 000012            78               add #12, sp
                                  79     
001314   000720                   80               br sysFind
                                  81     
001316   012601                   82     sysFinish:    mov (sp)+, r1
001320   000207                   83                   rts pc
                                  84     
                                  85     ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                  86     
001322                            87     encode:   ; 2(sp) - key, 4(sp) - hash, 6(sp) - nCols, 10(sp) - nRows, 12(sp) - OrigImg
                                  88               ; reveives the stack in the following way:
                                  89               ; push OrigImg
                                  90               ; push nRows
                                  91               ; push nCols
                                  92               ; push Hash
                                  93               ; push Key
001322   016646 000012            94               mov 12(sp), -(sp)         ;store the OrigImg pointer, so we can update it we the work on the current block
001326   010546                   95               mov r5, -(sp)
001330   005005                   96               clr r5
001332                            97     EncodeBlock:
001332   016646 000002            98               mov 2(sp), -(sp)
001336   016646 000010            99               mov 10(sp), -(sp)
001342   016646 000016           100               mov 16(sp), -(sp)
001346   004767 000224           101               jsr pc, EncryptBlock
001352   005726                  102               tst (sp)+
001354   005726                  103               tst (sp)+
001356   005726                  104               tst (sp)+
001360   016646 000002           105               mov 2(sp), -(sp)
001364   016646 000012           106               mov 12(sp), -(sp)
001370   016646 000016           107               mov 16(sp), -(sp)
001374   004767 000360           108               jsr pc, MixBlock
001400   005726                  109               tst (sp)+
001402   005726                  110               tst (sp)+
001404   005726                  111               tst (sp)+
001406   016646 000002           112               mov 2(sp), -(sp)
001412   016646 000010           113               mov 10(sp), -(sp)
001416   016646 000016           114               mov 16(sp), -(sp)
001422   005005                  115               clr r5
001424   004767 000146           116               jsr pc, EncryptBlock
001430   005726                  117               tst (sp)+
001432   005726                  118               tst (sp)+
001434   005726                  119               tst (sp)+
                                 120     
001436   010446                  121               mov r4, -(sp)       ;use r4 as a temp var for mul
001440   010346                  122               mov r3, -(sp)       ;use r3 as a temp var for mul
001442   005003                  123               clr r3
001444   117604 000016           124               movb @16(sp), r4    ;copy nCols
001450   016603 000016           125               mov 16(sp), r3      ;copy nRows
001454   005203                  126               inc r3
001456   111303                  127               movb (r3), r3
001460   070304                  128               mul r4, r3          ;we know the image size is less then 2^16
001462   010304                  129               mov r3, r4
001464   066604 000022           130               add 22(sp), r4      ; 22(sp) is the place where encode got OriImg address
001470   160504                  131               sub r5, r4          ;if we exceeded the blocks - should be negative
001472   005704                  132               tst r4
001474   100433                  133               bmi EEndEncodeR
001476   005704                  134               tst r4
001500   001023                  135               bne EDownMoveBlock
001502                           136     EMoveBlockRight:
001502   160305                  137               sub r3, r5          ;initialize the OrigImg pointer to the first line in the column.
001504   010566 000006           138               mov r5, 6(sp)       ;basically we substract the multiplication of nColsxnRows from the current
                                 139                                   ;place in the image's pointer (stored in 2(sp))
001510   062766 000004 000006    140               add #4, 6(sp)       ;move to next block from right
001516   016604 000006           141               mov 6(sp), r4
001522   005003                  142               clr r3
001524   117603 000016           143               movb @16(sp), r3    ;copy nCols value to r3
001530   160304                  144               sub r3, r4
001532   016603 000022           145               mov 22(sp), r3
001536   160403                  146               sub r4, r3
001540   001411                  147               beq EEndEncodeR     ;if the result=0, we exceeded nCols
                                 148     
001542   012603                  149               mov (sp)+, r3
001544   012604                  150               mov (sp)+, r4
001546   000671                  151               br EncodeBlock
001550                           152     EDownMoveBlock:
001550   012603                  153               mov (sp)+, r3
001552   012604                  154               mov (sp)+, r4
001554   010566 000002           155               mov r5, 2(sp)
001560   000664                  156               br EncodeBlock
001562   000402                  157               br DendEncode
001564                           158     EEndEncodeR:
001564   012603                  159               mov (sp)+, r3
001566   012604                  160               mov (sp)+, r4
001570                           161     DendEncode:
001570   012605                  162               mov (sp)+, r5
001572   005726                  163               tst (sp)+           ;pull the r5 we pushed earlier to return r1's value from the encription
001574   000207                  164               rts pc
                                 165               ;call to mix
                                 166               ;call to encryption
                                 167               ;loop with check bounderies
                                 168     
001576                           169     EncryptBlock:  ; 14(sp) - nCols address, 16(sp) - Key address, 20(sp) - OImg address
                                 170                    ; Order of passing parameters:
                                 171                    ; push Image address
                                 172                    ; push Key address
                                 173                    ; push nCols address
001576   010146                  174               mov r1, -(sp)
001600   010246                  175               mov r2, -(sp)
001602   010446                  176               mov r4, -(sp)
001604   010546                  177               mov r5, -(sp)
001606   010346                  178               mov r3, -(sp)
001610   005004                  179               clr r4
001612   016601 000020           180               mov 20(sp), r1
001616   016602 000016           181               mov 16(sp), r2
001622   017604 000014           182               mov @14(sp), r4
001626   042704 177400           183               bic #177400, r4                 ;gets lower byte of r4, which is nCols
001632   012705 000004           184               mov #4, r5                      ;set counters for sob
001636   012703 000004           185               mov #4, r3
001642                           186     LineEncrypt:
001642   010246                  187               mov r2,-(sp)                    ;store current node and put it's value in r2
001644   011202                  188               mov (r2),r2
001646   010146                  189               mov r1,-(sp)                    ;because r1 is byte, we store r1's address and move into it the value for xoring
001650   005001                  190               clr r1
001652   117601 000000           191               movb @0(sp), r1
001656   074201                  192               xor r2,r1
001660   110176 000000           193               movb r1, @0(sp)
001664   012601                  194               mov (sp)+, r1
001666   005201                  195               inc r1
001670   012602                  196               mov (sp)+, r2
001672   062702 000002           197               add #2, r2                       ;moves to next node in key
001676   027227 000000 177777    198               cmp @(r2), #177777
001704   001402                  199               beq EGetNewKey                    ;cycles again the key if nil
001706   005712                  200               tst(r2)
001710   001004                  201               bne EKeyIsOk
001712                           202     EGetNewKey:
001712   016602 000016           203               mov 16(sp), r2
001716   077527                  204               sob r5, LineEncrypt
001720   000402                  205               br ENextLine
001722   011202                  206     EKeyIsOk: mov (r2), r2                    ;get address of new key node
001724   077532                  207               sob r5, LineEncrypt
001726   162701 000004           208     ENextLine: sub #4, r1                       ;mov r1 to the beginning of line
001732   060401                  209               add r4, r1                      ;moves r4 one line forward
001734   012705 000004           210               mov #4, r5
001740   077340                  211               sob r3, LineEncrypt
001742   012603                  212               mov (sp)+, r3
001744   012605                  213               mov (sp)+, r5
001746   010105                  214               mov r1, r5
001750   012604                  215               mov (sp)+, r4
001752   012602                  216               mov (sp)+, r2
001754   012601                  217               mov (sp)+, r1
001756   000207                  218               rts pc
                                 219     
001760                           220     MixBlock: ; 14(sp) - nCols address, 16(sp) - Hash address, 20(sp) - OImg address
                                 221                ; Order of passing parameters:
                                 222                ; push Image address
                                 223                ; push Hash address
                                 224                ; push nCols address
001760   010146                  225               mov r1, -(sp)
001762   010246                  226               mov r2, -(sp)
001764   010446                  227               mov r4, -(sp)
001766   010546                  228               mov r5, -(sp)
001770   010346                  229               mov r3, -(sp)
001772   005004                  230               clr r4
001774   016601 000020           231               mov 20(sp), r1
002000   016602 000016           232               mov 16(sp), r2
002004   017604 000014           233               mov @14(sp), r4
002010   042704 177400           234               bic #177400, r4
002014   012705 000004           235               mov #4, r5
002020   012703 000004           236               mov #4, r3
002024   012746 000004           237               mov #4, -(sp)       ; counter for cyclic move
                                 238     
002030                           239     MixLine:
002030   010246                  240               mov r2, -(sp)
002032   010146                  241               mov r1, -(sp)       ; stores r1-index to img, r2-index to hash
                                 242     
002034   111101                  243               movb (r1), r1       ;get the value in image to use as index in Hash
002036   060102                  244               add r1, r2          ;advance r2 to desired index
002040   012601                  245               mov (sp)+, r1
002042   111202                  246               movb (r2), r2
002044   110221                  247               movb r2, (r1)+
002046   012602                  248               mov (sp)+, r2
002050   077311                  249               sob r3, MixLine
002052   162701 000004           250               sub #4, r1          ; initialize r1 to points to the first element in line
                                 251     
002056   010516                  252               mov r5,(sp)
002060   162716 000004           253               sub #4, (sp)        ;checks if cyclic move needs to be taken and how many moves should be done
002064   005416                  254               neg (sp)
002066   005716                  255               tst (sp)
002070   001423                  256               beq MNextLine
002072   010546                  257               mov r5, -(sp)       ;use r5 as counter for cyclic moves
002074   010346                  258               mov r3, -(sp)       ;use r3 as a temp register
002076                           259     ERepCyclicOp:
002076   005003                  260               clr r3
002100   012705 000003           261               mov #3, r5
002104   062701 000003           262               add #3, r1          ;r1 should point to the last element in line
002110   111103                  263               movb (r1), r3
                                 264     
002112   005301                  265     ECyclicOpLine:   dec r1              ;move the value of (r1) to the next byte
002114   111161 000001           266               movb (r1), 1(r1)
002120   005305                  267               dec r5
002122   001373                  268               bne ECyclicOpLine          ;if finished the cyclic move, continue
002124   110311                  269               movb r3, (r1)
002126   005366 000004           270               dec 4(sp)
002132   001361                  271               bne ERepCyclicOp        ;if finished cyclic operation on the line, continue
002134   012603                  272               mov (sp)+, r3
002136   012605                  273               mov (sp)+, r5
002140                           274     MNextLine:
002140   060401                  275               add r4, r1
002142   012703 000004           276               mov #4, r3
002146   077550                  277               sob r5, MixLine
002150   005726                  278               tst (sp)+
002152   012603                  279               mov (sp)+, r3
002154   012605                  280               mov (sp)+, r5
002156   012604                  281               mov (sp)+, r4
002160   012602                  282               mov (sp)+, r2
002162   012601                  283               mov (sp)+, r1
002164   000207                  284               rts pc
                                 285     
                                 286     ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                 287     
002166                           288     decode:   ; 2(sp) - key, 4(sp) - hash, 6(sp) - nCols, 10(sp) - nRows, 12(sp) - OrigImg
                                 289               ; reveives the stack in the following way:
                                 290               ; push OrigImg
                                 291               ; push nRows
                                 292               ; push nCols
                                 293               ; push Hash
                                 294               ; push Key
002166   016646 000012           295               mov 12(sp), -(sp)         ;store the EncImg pointer, so we can update it we the work on the current block
002172   010546                  296               mov r5, -(sp)
002174   005005                  297               clr r5
002176   016646 000002           298     DecodeBlock: mov 2(sp), -(sp)
002202   016646 000010           299               mov 10(sp), -(sp)
002206   016646 000016           300               mov 16(sp), -(sp)
002212   004767 000224           301               jsr pc, DecryptBlock
002216   005726                  302               tst (sp)+
002220   005726                  303               tst (sp)+
002222   005726                  304               tst (sp)+
002224   016646 000002           305               mov 2(sp), -(sp)
002230   016646 000012           306               mov 12(sp), -(sp)
002234   016646 000016           307               mov 16(sp), -(sp)
002240   004767 000360           308               jsr pc, UnmixBlock
002244   005726                  309               tst (sp)+
002246   005726                  310               tst (sp)+
002250   005726                  311               tst (sp)+
002252   016646 000002           312               mov 2(sp), -(sp)
002256   016646 000010           313               mov 10(sp), -(sp)
002262   016646 000016           314               mov 16(sp), -(sp)
002266   005005                  315               clr r5
002270   004767 000146           316               jsr pc, DecryptBlock
002274   005726                  317               tst (sp)+
002276   005726                  318               tst (sp)+
002300   005726                  319               tst (sp)+
                                 320     
002302   010446                  321               mov r4, -(sp)       ;use r4 as a temp var for mul
002304   010346                  322               mov r3, -(sp)       ;use r3 as a temp var for mul
002306   005003                  323               clr r3
002310   117604 000016           324               movb @16(sp), r4    ;copy nCols
002314   016603 000016           325               mov 16(sp), r3      ;copy nRows
002320   005203                  326               inc r3
002322   111303                  327               movb (r3), r3
002324   070304                  328               mul r4, r3          ;we know the image size is less then 2^16
002326   010304                  329               mov r3, r4
002330   066604 000022           330               add 22(sp), r4      ; 22(sp) is the place where encode got OriImg address
002334   160504                  331               sub r5, r4          ;if we exceeded the blocks - should be negative
002336   005704                  332               tst r4
002340   100433                  333               bmi DEndDecodeRight
002342   005704                  334               tst r4
002344   001023                  335               bne CompBlockDown
002346                           336     DMoveBlockRight:
002346   160305                  337               sub r3, r5          ;initialize the OrigImg pointer to the first line in the column.
002350   010566 000006           338               mov r5, 6(sp)       ;basically we substract the multiplication of nColsxnRows from the current
                                 339                                   ;place in the image's pointer (stored in 2(sp))
002354   062766 000004 000006    340               add #4, 6(sp)       ;move to next block from right
002362   016604 000006           341               mov 6(sp), r4
002366   005003                  342               clr r3
002370   117603 000016           343               movb @16(sp), r3    ;copy nCols value to r3
002374   160304                  344               sub r3, r4
002376   016603 000022           345               mov 22(sp), r3
002402   160403                  346               sub r4, r3
002404   001411                  347               beq DEndDecodeRight     ;if the result=0, we exceeded nCols
                                 348     
002406   012603                  349               mov (sp)+, r3
002410   012604                  350               mov (sp)+, r4
002412   000671                  351               br DecodeBlock
002414                           352     CompBlockDown:
002414   012603                  353               mov (sp)+, r3
002416   012604                  354               mov (sp)+, r4
002420   010566 000002           355               mov r5, 2(sp)
002424   000664                  356               br DecodeBlock
002426   000402                  357               br FinishDecode
002430                           358     DEndDecodeRight:
002430   012603                  359               mov (sp)+, r3
002432   012604                  360               mov (sp)+, r4
002434                           361     FinishDecode:
002434   012605                  362               mov (sp)+, r5
002436   005726                  363               tst (sp)+           ;pull the r5 we pushed earlier to return r1's value from the encription
002440   000207                  364               rts pc
                                 365               ;call to mix
                                 366               ;call to encryption
                                 367               ;loop with check bounderies
                                 368     
002442                           369     DecryptBlock:  ; 14(sp) - nCols address, 16(sp) - Key address, 20(sp) - OImg address
                                 370                    ; Order of passing parameters:
                                 371                    ; push Image address
                                 372                    ; push Key address
                                 373                    ; push nCols address
002442   010146                  374               mov r1, -(sp)
002444   010246                  375               mov r2, -(sp)
002446   010446                  376               mov r4, -(sp)
002450   010546                  377               mov r5, -(sp)
002452   010346                  378               mov r3, -(sp)
002454   005004                  379               clr r4
002456   016601 000020           380               mov 20(sp), r1
002462   016602 000016           381               mov 16(sp), r2
002466   017604 000014           382               mov @14(sp), r4
002472   042704 177400           383               bic #177400, r4                 ;gets lower byte of r4, which is nCols
002476   012705 000004           384               mov #4, r5                      ;set counters for sob
002502   012703 000004           385               mov #4, r3
002506                           386     DecryptLine:
002506   010246                  387               mov r2,-(sp)                    ;store current node and put it's value in r2
002510   011202                  388               mov (r2),r2
002512   010146                  389               mov r1,-(sp)                    ;because r1 is byte, we store r1's address and move into it the value for xoring
002514   005001                  390               clr r1
002516   117601 000000           391               movb @0(sp), r1
002522   074201                  392               xor r2,r1
002524   110176 000000           393               movb r1, @0(sp)
002530   012601                  394               mov (sp)+, r1
002532   005201                  395               inc r1
002534   012602                  396               mov (sp)+, r2
002536   062702 000002           397               add #2, r2                       ;moves to next node in key
002542   027227 000000 177777    398               cmp @(r2), #177777
002550   001402                  399               beq DGetNewKey                    ;cycles again the key if nil
002552   005712                  400               tst(r2)
002554   001004                  401               bne DKeyLenIsOk
002556                           402     DGetNewKey:
002556   016602 000016           403               mov 16(sp), r2
002562   077527                  404               sob r5, DecryptLine
002564   000402                  405               br DNextLine
002566   011202                  406     DKeyLenIsOk: mov (r2), r2                    ;get address of new key node
002570   077532                  407               sob r5, DecryptLine
002572   162701 000004           408     DNextLine: sub #4, r1                       ;mov r1 to the beginning of line
002576   060401                  409               add r4, r1                      ;moves r4 one line forward
002600   012705 000004           410               mov #4, r5
002604   077340                  411               sob r3, DecryptLine
002606   012603                  412               mov (sp)+, r3
002610   012605                  413               mov (sp)+, r5
002612   010105                  414               mov r1, r5
002614   012604                  415               mov (sp)+, r4
002616   012602                  416               mov (sp)+, r2
002620   012601                  417               mov (sp)+, r1
002622   000207                  418               rts pc
                                 419     
002624                           420     UnmixBlock: ; 14(sp) - nCols address, 16(sp) - Hash address, 20(sp) - OImg address
                                 421                ; Order of passing parameters:
                                 422                ; push Image address
                                 423                ; push Hash address
                                 424                ; push nCols address
002624   010146                  425               mov r1, -(sp)
002626   010246                  426               mov r2, -(sp)
002630   010446                  427               mov r4, -(sp)
002632   010546                  428               mov r5, -(sp)
002634   010346                  429               mov r3, -(sp)
002636   005004                  430               clr r4
002640   016601 000020           431               mov 20(sp), r1
002644   016602 000016           432               mov 16(sp), r2
002650   017604 000014           433               mov @14(sp), r4
002654   042704 177400           434               bic #177400, r4
002660   012705 000004           435               mov #4, r5
002664   012703 000004           436               mov #4, r3
002670   012746 000004           437               mov #4, -(sp)       ; counter for cyclic move
                                 438     
002674                           439     LineUnmix:
002674   010246                  440               mov r2, -(sp)
002676   010146                  441               mov r1, -(sp)       ; stores r1-index to img, r2-index to hash
002700   010346                  442               mov r3, -(sp)       ;temp iterator for Hash array
002702   005003                  443               clr r3
002704   111101                  444               movb (r1), r1
002706                           445     DCalculateIndex:                     ;goes over Hash values until it matches (r1)
002706   120122                  446               cmpb r1, (r2)+
002710   001402                  447               beq IndexFound
002712   005203                  448               inc r3
002714   000774                  449               br DCalculateIndex
002716                           450     IndexFound:
002716   110376 000002           451               movb r3, @2(sp)
002722   005266 000002           452               inc 2(sp)
002726   012603                  453               mov (sp)+, r3
002730   012601                  454               mov (sp)+, r1
002732   012602                  455               mov (sp)+, r2
002734   077321                  456               sob r3, LineUnmix
002736   162701 000004           457               sub #4, r1          ; initialize r1 to points to the first element in line
                                 458     
002742   010516                  459               mov r5,(sp)         ;r5 = 4 in the beginning
                                 460               ;sub #4, (sp)        ;checks if cyclic move needs to be taken and how many moves should be done
                                 461               ;neg (sp)
002744   021627 000004           462               cmp (sp), #4
002750   001423                  463               beq DNextRow
002752   010546                  464               mov r5, -(sp)       ;use r5 as counter for cyclic moves
002754   010346                  465               mov r3, -(sp)       ;use r3 as a temp register
002756                           466     DCyclicRep:
002756   005003                  467               clr r3
002760   012705 000003           468               mov #3, r5
002764   062701 000003           469               add #3, r1          ;r1 should point to the last element in line
002770   111103                  470               movb (r1), r3
                                 471     
002772                           472     DCyclicLineOp:
002772   005301                  473               dec r1              ;move the value of (r1) to the next byte
002774   111161 000001           474               movb (r1), 1(r1)
003000   005305                  475               dec r5
003002   001373                  476               bne DCyclicLineOp          ;if finished the cyclic move, continue
003004   110311                  477               movb r3, (r1)
003006   005366 000004           478               dec 4(sp)
003012   001361                  479               bne DCyclicRep        ;if finished cyclic operation on the line, continue
003014   012603                  480               mov (sp)+, r3
003016   012605                  481               mov (sp)+, r5
003020                           482     DNextRow:
003020   060401                  483               add r4, r1
003022   012703 000004           484               mov #4, r3
003026   077556                  485               sob r5, LineUnmix
003030   005726                  486               tst (sp)+
003032   012603                  487               mov (sp)+, r3
003034   012605                  488               mov (sp)+, r5
003036   012604                  489               mov (sp)+, r4
003040   012602                  490               mov (sp)+, r2
003042   012601                  491               mov (sp)+, r1
003044   000207                  492               rts pc
                                 493     
                                 494     ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                 495     
003046                           496     isLegal: ; 0(r5)=Img , 2(r5)=nRows , 4(r5)=nCols , 6(r5)=OUTPUT
                                 497     
003046   010146                  498                   mov r1, -(sp)
003050   010246                  499                   mov r2, -(sp)
003052   010346                  500                   mov r3, -(sp)
                                 501     
003054   011501                  502                   mov (r5), r1       ; (r5)=Img
                                 503     
003056   121127 000017           504     lglByte:      cmpb (r1), #17
003062   101013                  505                   bhi lglFalse          ; if [0 <= (r1) <= 17]
                                 506     
003064   117502 000002           507                   movb @2(r5), r2       ; @2(r5)=nRows
003070   117503 000004           508                   movb @4(r5), r3       ; @4(r5)=nCols
003074   070302                  509                   mul r2, r3         ; r3=nCols*nRows
                                 510     
003076   061503                  511                   add (r5), r3      ; (r5)=Img1
003100   005303                  512                   dec r3
003102   020301                  513                   cmp r3, r1
003104   003406                  514                   ble lglTrue       ; if r1 reached the end of Img
                                 515     
003106   005201                  516                   inc r1
003110   000762                  517                   br lglByte
                                 518     
003112   012765 000000 000006    519     lglFalse:     mov #0, 6(r5)
003120   000404                  520                   br lglFinish
                                 521     
003122   012765 000001 000006    522     lglTrue:      mov #1, 6(r5)
003130   000400                  523                   br lglFinish
                                 524     
003132   012603                  525     lglFinish:    mov (sp)+, r3
003134   012602                  526                   mov (sp)+, r2
003136   012601                  527                   mov (sp)+, r1
003140   062705 000010           528                   add #10, r5
003144   000205                  529                   rts r5
                                 530     
                                 531     ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                 532     
003146                           533     cmpImg: ; 2(sp)=OUTPUT , 4(sp)=nCols , 6(sp)=nRows , 10(sp)=Img2, 12(sp)=Img1
                                 534     
003146   010146                  535                   mov r1, -(sp)
003150   010246                  536                   mov r2, -(sp)
003152   010346                  537                   mov r3, -(sp)
003154   010446                  538                   mov r4, -(sp)
                                 539     
003156   016601 000020           540                   mov 20(sp), r1       ; Img1
003162   016602 000016           541                   mov 16(sp), r2        ; Img2
                                 542     
003166   121112                  543     cmpByte:      cmpb (r1), (r2)
003170   001016                  544                   bne cmpFalse            ; if [(r1) == (r2)]
                                 545     
003172   005003                  546                   clr r3
003174   117603 000012           547                   movb @12(sp), r3
003200   117604 000014           548                   movb @14(sp), r4
003204   070304                  549                   mul r4, r3         ; r3=nCols*nRows
                                 550     
003206   066603 000020           551                   add 20(sp), r3      ; 20(sp)=Img1
003212   005303                  552                   dec r3
003214   020301                  553                   cmp r3, r1
003216   003407                  554                   ble cmpTrue         ; if r1 reached the end of Img
                                 555     
003220   005201                  556                   inc r1
003222   005202                  557                   inc r2
003224   000760                  558                   br cmpByte
                                 559     
003226   012766 000001 000022    560     cmpFalse:     mov #1, 22(sp)
003234   000404                  561                   br cmpFinish
                                 562     
003236   012766 000000 000022    563     cmpTrue:      mov #0, 22(sp)
003244   000400                  564                   br cmpFinish
                                 565     
003246   012604                  566     cmpFinish:    mov (sp)+, r4
003250   012603                  567                   mov (sp)+, r3
003252   012602                  568                   mov (sp)+, r2
003254   012601                  569                   mov (sp)+, r1
003256   000207                  570                   rts pc
                                 571     
                                 572     ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                 573     
003260                           574     nextKey: ; r1=key
003260   010146                  575                   mov r1, -(sp)           ; saves list's head
                                 576     
003262   021127 000017           577     nkCheckKey:   cmp (r1), #17           ; checks if "17-17-17-..."
003266   002406                  578                   blt nkStart
003270   062701 000002           579                   add #2, r1
003274   005711                  580                   tst (r1)
003276   001415                  581                   beq nkFinish
003300   011101                  582                   mov (r1), r1
003302   000767                  583                   br nkCheckKey
                                 584     
003304   012601                  585     nkStart:      mov (sp)+, r1           ; restors list's head
003306   021127 000017           586     nkIncNode:    cmp (r1), #17
003312   002002                  587                   bge nkNextNode
                                 588     
003314   005211                  589                   inc (r1)
003316   000405                  590                   br nkFinish
                                 591     
003320   005011                  592     nkNextNode:   clr (r1)
003322   062701 000002           593                   add #2, r1
003326   011101                  594                   mov (r1), r1
003330   000766                  595                   br nkIncNode
                                 596     
003332   000207                  597     nkFinish:     rts pc
                                 598     
                                 599     ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                 600     
003334   000000                  601     finish: halt
003336                           602     .= torg + 11000
011000      010                  603     nCols: 		.byte 10
011001      004                  604     nRows: 	.byte 4
011002      001    002    001    605     OrigImg: 	.byte	 1,  2,  1,  2, 0,   1,   2,    3
            002    000    001            
            002    003                   
011012      003    004    003    606     				.byte	 3,  4,  3,  4, 4,   5,   6,    7
            004    004    005            
            006    007                   
011022      005    006    005    607     				.byte	 5,  6,  5,  6, 10, 11, 12, 13
            006    010    011            
            012    013                   
011032      007    000    007    608     				.byte	 7,  0,  7,  0, 14, 15, 16, 17
            000    014    015            
            016    017                   
011042      003    004    003    609     EncImg: 	.byte	 3,  4,  3,  4,  2,  3,   4,    5
            004    002    003            
            004    005                   
011052      007    004    007    610     				.byte	 7,  4,  7,  4,  10,   7,   6,    11
            004    010    007            
            006    011                   
011062      007    010    007    611     				.byte	 7,  10,  7,  10, 14, 15, 12, 13
            010    014    015            
            012    013                   
011072      003    010    003    612     				.byte	 3,  10,  3,  10, 16, 1, 0, 17
            010    016    001            
            000    017                   
011102      002    003    004    613     Hash:		.byte 	2,3,4,5,6,7,10,11,12,13,14,15,16,17,0,1
            005    006    007            
            010    011    012            
            013    014    015            
            016    017    000            
            001                          
011122                           614     .even
011122                           615     Key:
011122   177777 011126           616     node1:		.word -1, node2
011126   177777 011132           617     node2:		.word -1, node3
011132   177777 000000           618     node3:		.word -1, 0
011136                           619     ExpKey:
011136   000000 011142           620     _node1:		.word  0, _node2
011142   000001 011146           621     _node2:		.word  1, _node3
011146   000002 000000           622     _node3:		.word  2, 0


	S Y M B O L   T A B L E
	=======================

SYMBOL    VALUE   TYPE
------    -----   ----
main      001000  text     
nCols     011000  text     
nRows     011001  text     
jumpFini  001112  text     
isLegal   003046  text     
OrigImg   011002  text     
EncImg    011042  text     
Hash      011102  text     
system    001116  text     
finish    003334  text     
cmpImg    003146  text     
sysFinis  001316  text     
sysFind   001156  text     
Key       011122  text     
nextKey   003260  text     
encode    001322  text     
decode    002166  text     
EncodeBl  001332  text     
EncryptB  001576  text     
MixBlock  001760  text     
EEndEnco  001564  text     
EDownMov  001550  text     
EMoveBlo  001502  text     
DendEnco  001570  text     
LineEncr  001642  text     
EGetNewK  001712  text     
EKeyIsOk  001722  text     
ENextLin  001726  text     
MixLine   002030  text     
MNextLin  002140  text     
ERepCycl  002076  text     
ECyclicO  002112  text     
DecodeBl  002176  text     
DecryptB  002442  text     
UnmixBlo  002624  text     
DEndDeco  002430  text     
CompBloc  002414  text     
DMoveBlo  002346  text     
FinishDe  002434  text     
DecryptL  002506  text     
DGetNewK  002556  text     
DKeyLenI  002566  text     
DNextLin  002572  text     
LineUnmi  002674  text     
DCalcula  002706  text     
IndexFou  002716  text     
DNextRow  003020  text     
DCyclicR  002756  text     
DCyclicL  002772  text     
lglByte   003056  text     
lglFalse  003112  text     
lglTrue   003122  text     
lglFinis  003132  text     
cmpByte   003166  text     
cmpFalse  003226  text     
cmpTrue   003236  text     
cmpFinis  003246  text     
nkCheckK  003262  text     
nkStart   003304  text     
nkFinish  003332  text     
nkIncNod  003306  text     
nkNextNo  003320  text     
node1     011122  text     
node2     011126  text     
node3     011132  text     
ExpKey    011136  text     
_node1    011136  text     
_node2    011142  text     
_node3    011146  text     
