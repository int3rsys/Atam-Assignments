. = torg + 1000
main:   mov #main, sp

        tst -(sp)
        mov #OrigImg, -(sp)
        mov #EncImg, -(sp)
        mov #nRows, -(sp)
        mov #nCols, -(sp)

        jsr pc, cmpImg

        add #10, sp
        jmp finish

cmpImg: ; 2(sp)=OUTPUT , 4(sp)=nCols , 6(sp)=nRows , 10(sp)=Img2, 12(sp)=Img1

              mov r1, -(sp)
              mov r2, -(sp)
              mov r3, -(sp)
              mov r4, -(sp)

              mov 20(sp), r1       ; Img1
              mov 16(sp), r2        ; Img2

cmpByte:      cmpb (r1), (r2)
              bne cmpFalse            ; if [(r1) == (r2)]

              clr r3
              movb @12(sp), r3
              movb @14(sp), r4
              mul r4, r3         ; r3=nCols*nRows

              add 20(sp), r3      ; 20(sp)=Img1
              dec r3
              cmp r3, r1
              ble cmpTrue         ; if r1 reached the end of Img

              inc r1
              inc r2
              br cmpByte

cmpFalse:     mov #1, 22(sp)
              br cmpFinish

cmpTrue:      mov #0, 22(sp)
              br cmpFinish

cmpFinish:    mov (sp)+, r4
              mov (sp)+, r3
              mov (sp)+, r2
              mov (sp)+, r1
              rts pc

finish: halt
.= torg + 11000
nCols: 		.byte 10
nRows: 	.byte 4
OrigImg: 	.byte	 1,  2,  1,  2, 0,   1,   2,    3
				.byte	 3,  4,  3,  4, 4,   5,   6,    7
				.byte	 5,  6,  5,  6, 10, 11, 12, 13
				.byte	 7,  0,  7,  0, 14, 15, 16, 17
EncImg: 	.byte	 3,  4,  3,  4,  2,  3,   4,    5
				.byte	 7,  4,  7,  4,  10,   7,   6,    11
				.byte	 7,  10,  7,  10, 14, 15, 12, 13
				.byte	 3,  10,  3,  10, 16, 1, 0, 17
Hash:		.byte 	2,3,4,5,6,7,10,11,12,13,14,15,16,17,0,1
.even
Key:
node1:		.word -1, node2
node2:		.word -1, node3
node3:		.word -1, 0
ExpKey:
_node1:		.word  0, _node2
_node2:		.word  1, _node3
_node3:		.word  2, 0
