. = torg + 1000
<<<<<<< HEAD
main:   mov #main, sp

        mov #OrigImg, -(sp)
        movb nRows, -(sp)
        movb nCols, -(sp)
        mov #Hash, -(sp)
        mov #ExpKey, -(sp)

        jsr pc, decode

        tstb (sp)+
        tstb (sp)+
        tstb (sp)+
        tstb (sp)+
        tstb (sp)+

        jmp finish

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

encryptBlock:  ; 10(sp) - nCols address, 12(sp) - Key address, 14(sp) - OImg address
          mov r1, -(sp)
          mov r2, -(sp)
          mov r4, -(sp)
          clr r4
          mov 14(sp), r1
          mov 12(sp), r2
          mov @10(sp), r4
          bic #177400, r4                 ;gets lower byte of r4, which is nCols
          mov #4, r5                      ;set counters for sob
          mov #4, r3
encryptLine:
=======
main:	mov	pc,	sp
          tst	-(sp)
          mov #EncImg, -(sp)
          mov #nRows, -(sp)
          mov #nCols, -(sp)
          mov #Hash, -(sp)
          mov #Key, -(sp)
          jsr pc, decode
          tst (sp)+
          tst (sp)+
          tst (sp)+
          tst (sp)+
          tst (sp)+
decode:   ; 2(sp) - key, 4(sp) - hash, 6(sp) - nCols, 10(sp) - nRows, 12(sp) - OrigImg
          ; reveives the stack in the following way:
          ; push OrigImg
          ; push nRows
          ; push nCols
          ; push Hash
          ; push Key
          mov 12(sp), -(sp)         ;store the EncImg pointer, so we can update it we the work on the current block
          mov r5, -(sp)
          clr r5
decBlock: mov 2(sp), -(sp)
          mov 10(sp), -(sp)
          mov 16(sp), -(sp)
          jsr pc, decryptBlock
          tst (sp)+
          tst (sp)+
          tst (sp)+
          mov 2(sp), -(sp)
          mov 12(sp), -(sp)
          mov 16(sp), -(sp)
          jsr pc, unmixBlock
          tst (sp)+
          tst (sp)+
          tst (sp)+
          mov 2(sp), -(sp)
          mov 10(sp), -(sp)
          mov 16(sp), -(sp)
          clr r5
          jsr pc, decryptBlock
          tst (sp)+
          tst (sp)+
          tst (sp)+

          mov r4, -(sp)       ;use r4 as a temp var for mul
          mov r3, -(sp)       ;use r3 as a temp var for mul
          clr r3
          movb @16(sp), r4    ;copy nCols
          mov 16(sp), r3      ;copy nRows
          inc r3
          movb (r3), r3
          mul r4, r3          ;we know the image size is less then 2^16
          mov r3, r4
          add 22(sp), r4      ; 22(sp) is the place where encode got OriImg address
          sub r5, r4          ;if we exceeded the blocks - should be negative
          tst r4
          bmi endEncodeR
          tst r4
          bne downMoveBlock
moveBlockRight:
          sub r3, r5          ;initialize the OrigImg pointer to the first line in the column.
          mov r5, 6(sp)       ;basically we substract the multiplication of nColsxnRows from the current
                              ;place in the image's pointer (stored in 2(sp))
          add #4, 6(sp)       ;move to next block from right
          mov 6(sp), r4
          clr r3
          movb @16(sp), r3    ;copy nCols value to r3
          sub r3, r4
          mov 22(sp), r3
          sub r4, r3
          beq endEncodeR     ;if the result=0, we exceeded nCols

          mov (sp)+, r3
          mov (sp)+, r4
          br decBlock
downMoveBlock:
          mov (sp)+, r3
          mov (sp)+, r4
          mov r5, 2(sp)
          br decBlock
          br DendEncode
endEncodeR:
          mov (sp)+, r3
          mov (sp)+, r4
DendEncode:
          mov (sp)+, r5
          tst (sp)+           ;pull the r5 we pushed earlier to return r1's value from the encription
          rts pc
          ;call to mix
          ;call to encryption
          ;loop with check bounderies

decryptBlock:  ; 14(sp) - nCols address, 16(sp) - Key address, 20(sp) - OImg address
               ; Order of passing parameters:
               ; push Image address
               ; push Key address
               ; push nCols address
          mov r1, -(sp)
          mov r2, -(sp)
          mov r4, -(sp)
          mov r5, -(sp)
          mov r3, -(sp)
          clr r4
          mov 20(sp), r1
          mov 16(sp), r2
          mov @14(sp), r4
          bic #177400, r4                 ;gets lower byte of r4, which is nCols
          mov #4, r5                      ;set counters for sob
          mov #4, r3
decryptLine:
>>>>>>> 947ec4493c6b4098cc691c6cd0360212e1adfa0e
          mov r2,-(sp)                    ;store current node and put it's value in r2
          mov (r2),r2
          mov r1,-(sp)                    ;because r1 is byte, we store r1's address and move into it the value for xoring
          clr r1
          movb @0(sp), r1
          xor r2,r1
          movb r1, @0(sp)
          mov (sp)+, r1
          inc r1
          mov (sp)+, r2
          add #2, r2                       ;moves to next node in key
<<<<<<< HEAD
          tst (r2)
          bne keyLenOK                    ;cycles again the key if nil
          mov 12(sp), r2
          sob r5, encryptLine
          br nextLine
keyLenOK: mov (r2), r2                    ;get address of new key node
          sob r5, encryptLine
nextLine: sub #4, r1                       ;mov r1 to the beginning of line
          add r4, r1                      ;moves r4 one line forward
          mov #4, r5
          sob r3, encryptLine
=======
          cmp @(r2), #177777
          beq getNewKey                    ;cycles again the key if nil
          tst(r2)
          bne keyLenOK
getNewKey:
          mov 16(sp), r2
          sob r5, decryptLine
          br nextLine
keyLenOK: mov (r2), r2                    ;get address of new key node
          sob r5, decryptLine
nextLine: sub #4, r1                       ;mov r1 to the beginning of line
          add r4, r1                      ;moves r4 one line forward
          mov #4, r5
          sob r3, decryptLine
          mov (sp)+, r3
          mov (sp)+, r5
          mov r1, r5
>>>>>>> 947ec4493c6b4098cc691c6cd0360212e1adfa0e
          mov (sp)+, r4
          mov (sp)+, r2
          mov (sp)+, r1
          rts pc

<<<<<<< HEAD
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

decode: ;2(sp)=Key, 4(sp)=Hash, 6(sp)=nCols, 10(sp)=nRows, 12(sp)=Img

        mov 6(sp), -(sp) ; nCols
        mov 4(sp), -(sp) ; key
        mov 16(sp), -(sp) ; Img
        jsr pc, encryptBlock
        tst (sp)+
        tst (sp)+
        tst (sp)+

        mov 12(sp), -(sp) ; Img
        movb 12(sp), -(sp) ; nRows
        movb 12(sp), -(sp) ; nCols
        mov 12(sp), -(sp) ; Hash
        mov 12(sp), -(sp) ; Key
        jsr pc, restore
        tst (sp)+
        tst (sp)+
        tst (sp)+
        tst (sp)+
        tst (sp)+

        mov 6(sp), -(sp) ; nCols
        mov 4(sp), -(sp) ; key
        mov 16(sp), -(sp) ; Img
        jsr pc, encryptBlock
        tst (sp)+
        tst (sp)+
        tst (sp)+

        rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

restore: ;2(sp)=Key, 4(sp)=Hash, 6(sp)=nCols, 10(sp)=nRows, 12(sp)=Img
            mov r1, -(sp)
            mov r2, -(sp)

            mov 16(sp), r1             ; Img
            mov 10(sp), r2             ; Hash



DecLine:		mov #-1, restoreTemp					;initialize Temp as counter in Hash
DecByte:		inc restoreTemp							;find the corresponding index for value in
																;Hash that is equal to value in Img
						cmpb (r1), (r2)+			; --""--
						bne DecByte						; --""--

						mov #Hash, r2					;initialize r2 to pointer to Hash
						movb restoreTemp, (r1)+			;decrypt byte
						dec restoreInLineL
						bne DecLine
						sub #4,r1							;initialize r1 to the start of a block's line

						mov restoreRowLoop, restoreLineCyclic		;Initialize cyclic counter
						sub #4,restoreLineCyclic					; --""--
						neg restoreLineCyclic						; --""--

						tst restoreLineCyclic
						beq DecDntCycl							;if Cyclic counter != 0 then don't cycle

DecRepCycl:	mov #3, restoreInLineL							;initialize InLineL for cyclic move loop

						clr restoreTemp										;stores the first byte in a block's line
						movb (r1), restoreTemp							; --""--

DecCyclMov:	inc r1
						movb (r1),-1(r1)						;mov value in next byte to the previous byte
						dec restoreInLineL									; --""--
						bne DecCyclMov							;if finished cycle move for line, continue
						movb restoreTemp, (r1)							;restore the value stored in Temp
						sub #3, r1									;initialize r1
						dec restoreLineCyclic
						bne DecRepCycl							;repeat cyclic move in block

DecDntCycl:	clr restoreTemp										;move to the next block's line
						movb 12(sp), restoreTemp						; --""-- 12(sp) == nCols
						add restoreTemp, r1								; --""--

						mov #4, restoreInLineL							;initialize InLineL for DecLine loop
						dec restoreRowLoop
						bne DecLine

            mov (sp)+, r2
            mov (sp)+, r1

          rts pc

          restoreTemp: .word 0
          restoreInLineL: .word 4
          restoreLineCyclic: .word 	0
          restoreRowLoop: .word 	4

finish: halt
.= torg + 11000
nCols: 		.byte 10
nRows: 	.byte 4
OrigImg: 	.byte	 1,  2,  1,  2, 0,   1,   2,    3
				.byte	 3,  4,  3,  4, 4,   5,   6,    7
				.byte	 5,  6,  5,  6, 10, 11, 12, 13
				.byte	 7,  0,  7,  0, 14, 15, 16, 17
EncImg: 	.byte	 3,  4,  3,  4,  2,  3,   4,    5
				.byte	 7,  4,  7,  4,  10,   7,   6,    11
				.byte	 7,  10,  7,  10, 14, 15, 12, 13
				.byte	 3,  10,  3,  10, 16, 1, 0, 17
Hash:		.byte 	2,3,4,5,6,7,10,11,12,13,14,15,16,17,0,1
.even
Key:
node1:		.word -1, node2
node2:		.word -1, node3
node3:		.word -1, 0
ExpKey:
_node1:		.word  0, _node2
_node2:		.word  1, _node3
_node3:		.word  2, 0
=======
unmixBlock: ; 14(sp) - nCols address, 16(sp) - Hash address, 20(sp) - OImg address
           ; Order of passing parameters:
           ; push Image address
           ; push Hash address
           ; push nCols address
          mov r1, -(sp)
          mov r2, -(sp)
          mov r4, -(sp)
          mov r5, -(sp)
          mov r3, -(sp)
          clr r4
          mov 20(sp), r1
          mov 16(sp), r2
          mov @14(sp), r4
          bic #177400, r4
          mov #4, r5
          mov #4, r3
          mov #4, -(sp)       ; counter for cyclic move

unmixLine:
          mov r2, -(sp)
          mov r1, -(sp)       ; stores r1-index to img, r2-index to hash
          mov r3, -(sp)       ;temp iterator for Hash array
          clr r3
          movb (r1), r1
calcIndex:                     ;goes over Hash values until it matches (r1)
          cmpb r1, (r2)+
          beq indexFound
          inc r3
          br calcIndex
indexFound:
          movb r3, 2(r1)
          inc 2(sp)
          mov (sp)+, r3
          mov (sp)+, r1
          mov (sp)+, r2
          sob r3, unmixLine
          sub #4, r1          ; initialize r1 to points to the first element in line

          mov r5,(sp)         ;r5 = 4 in the beginning
          sub #4, (sp)        ;checks if cyclic move needs to be taken and how many moves should be done
          neg (sp)
          tst (sp)
          beq nextRow
          mov r5, -(sp)       ;use r5 as counter for cyclic moves
          mov r3, -(sp)       ;use r3 as a temp register
cycleRep:
          clr r3
          mov #3, r5
          movb (r1), r3

cycleL:   inc r1              ;move the value of (r1) to the next byte
          movb (r1), -1(r1)
          dec r5
          bne cycleL          ;if finished the cyclic move, continue
          movb r3, (r1)
          dec 4(sp)
          bne cycleRep        ;if finished cyclic operation on the line, continue
          mov (sp)+, r3
          mov (sp)+, r5
nextRow:
          add r4, r1
          mov #4, r3
          sob r5, unmixLine
          tst (sp)+
          mov (sp)+, r3
          mov (sp)+, r5
          mov (sp)+, r4
          mov (sp)+, r2
          mov (sp)+, r1
          rts pc


halt



. = torg + 5000
nCols: .byte 10
nRows: .byte 4
OrigImg: .byte 1, 2, 1, 2, 0, 1, 2, 3
.byte 3, 4, 3, 4, 4, 5, 6, 7
.byte 5, 6, 5, 6, 10, 11, 12, 13
.byte 7, 0, 7, 0, 14, 15, 16, 17

EncImg: .byte 3, 4, 3, 4, 2, 3, 4, 5
.byte 7, 4, 7, 4, 10, 7, 6, 11
.byte 7, 10, 7, 10, 14, 15, 12, 13
.byte 3, 10, 3, 10, 16, 1, 0, 17

Hash: .byte 2,3,4,5,6,7,10,11,12,13,14,15,16,17,0,1
Key:
node1:  .word 1,node2
node2:  .word 0,node3
node3:  .word -1,0
>>>>>>> 947ec4493c6b4098cc691c6cd0360212e1adfa0e
