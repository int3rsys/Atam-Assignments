;test

. = torg + 1000
main:			mov #Img, r1					;set r1 as pointer to Img's beginning
					mov #Hash, r2					;set r2 as pointer to Hash's beginnig
					mov #output, r4				;set r4 as pointer to Output's beginning

					clr r3								;calculate nCols x nRows and store in r3
					clr Temp							; --""--
					movb nCols, r3				; --""--
					movb nRows, Temp			; --""--
					mul Temp, r3					; --""--

dupLoop:	movb (r1)+,(r4)+ 			; duplicate Img into Output label
					sob r3, dupLoop				; --""--

					mov #output, r1				; initialize r1

					cmpb Enc, #1
					beq encrypt						;if Enc==1, jump to encrypt label
					jmp decrypt						;else jump to decrypt label

encrypt:

EncLine:	clr Temp
					movb (r1), Temp				;add value stored by pointer r1 (points to Img array) to r2
					add Temp, r2					; --""--
					movb (r2),(r1)+				; --""-- and moves to next byte in the line
					mov #Hash,r2					; --""--

					dec InLineL
					bne EncLine 					;using first nested loop for each byte in block's line, encrypting it by Hash function
					sub #4,r1							;initialize r1 to the first element in a block's line

					mov RowLoop, InLineCyclic		;Initialize cyclic counter
					sub #4,InLineCyclic					; --""--
					neg InLineCyclic						; --""--

					tst InLineCyclic
					beq dontCycl					;if inline cyclic == 0, pass

repCycl:	mov #3, InLineL				;initialize InLineL for cyclMov loop
					add #3,r1							;initialize r1 to point to the last element in a block's line


					clr Temp							;Initialize temp and place in it the last element in the line
					movb (r1), Temp				; --""--

cyclMov:	dec r1								;move the value of (r1) to the next byte
					movb (r1),1(r1)				; --""--
					dec InLineL
					bne cyclMov						;if finished one cyclic move, continue
					movb Temp, (r1)				;restore the last element, last part of the cyclic move
					dec InLineCyclic
					bne repCycl						;if finished cyclic operation on the line, continue

dontCycl:	clr Temp							;moves r1 to point to a beginning of the next line in a block
					movb nCols, Temp			; --""--
					add Temp, r1					; --""--

					mov #4, InLineL				;initialize InLineL for first nested loop
					dec RowLoop
					bne EncLine						;using second nested loop for each line in Img's block, Encrypting it by cyclic move


					clr r4								; if(((r1-output)/nCols) >= nRows) continue | checks if we didn't bypass nRows, therefore if the
																; index is still legal
					mov r1, r5						; --""--
					sub #output, r5				; --""--
					clr Temp							; --""--
					movb nCols, Temp			; --""--
					div Temp, r4					; --""--
					clr Temp							; --""--
					movb nRows, Temp			; --""--
					mov #4, RowLoop				; --""--
					cmp r4, Temp					; --""--
					blo EncLine						; --""--


					clr Temp							; calculates nRows x nCols and stores it in r3
					movb nCols, Temp			; --""--
					mov Temp, r3					; --""--
					clr Temp							; --""--
					movb nRows, Temp			; --""--
					mul Temp, r3					; --""--

					sub r3, r1						; update r1 to the next block's column
					add #4, r1						; --""--

					mov r1, r4						; if (((r1-output)>=nCols)) continue
					sub #output, r4				; --""--
					clr Temp							; --""--
					movb nCols, Temp			; --""--
					cmp r4, Temp					; --""--
					blt EncLine						; --""--
halt

decrypt:	mov #5, r5

halt
.even
InLineCyclic:		.word 	0
Temp:						.word 	0
InLineL:	 			.word		4
RowLoop:				.word 	4
nCols: 					.byte 	10
nRows: 					.byte 	4
Enc: 						.byte		1
Img: 						.byte 	1, 2, 1, 2, 0, 1, 2, 3
								.byte 	3, 4, 3, 4, 4, 5, 6, 7
								.byte 	5, 6, 5, 6, 10, 11, 12, 13
								.byte		7, 0, 7, 0, 14, 15, 16, 17
Hash:						.byte 	2,3,4,5,6,7,10,11,12,13,14,15,16,17,0,1
output:					.byte 	0
